<application>
  <component name="AppStorage">
    <histories>
      <item value="Accumulate" />
      <item value="traverse" />
      <item value="create 8 directional lights to speed up the convergence" />
      <item value="If this object is a light, simply add it to the internal scene" />
      <item value="Set the Previous Frame's Texture Buffer and Averaging Window" />
      <item value="randomize the lookup values to hide the fixed number of samples \" />
      <item value="Fragment Shader: Set Pixels to average in the Previous frame's Shadows" />
      <item value="Standard" />
      <item value="Whether" />
      <item value="boolean" />
      <item value="number" />
      <item value="Camera" />
      <item value="Shader" />
      <item value="Vertex" />
      <item value="Progressive" />
      <item value="rogressive Surfacemap" />
      <item value="Ratio" />
      <item value="Orbit" />
      <item value="compatibility" />
      <item value="World" />
      <item value="Sphere" />
      <item value="Blend Color" />
      <item value="@description This function reprojects textures between cubemap, equirectangular and octahedral formats. The function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats. When specularPower is specified it will perform a phong-weighted convolution of the source (for generating a gloss maps)." />
      <item value="read scanline width specifier" />
      <item value="check first scanline width to determine whether the file is RLE" />
      <item value="RGBE can't be filtered, so mipmaps are out of the question! (unless we generated them ourselves)" />
      <item value="@description Clamps texture coordinate to the range 0 to 1." />
      <item value="@description Ignores the integer part of texture coordinates, using only the fractional part." />
      <item value="@description Transforms a 4-dimensional vector by a 4x4 matrix." />
      <item value="@description Each element is rounded up to the next largest integer." />
      <item value="@description Each element is rounded up or down to the nearest integer." />
      <item value="@description Sets the specified matrix to a viewing matrix derived from an eye point, a target point and an up vector. The matrix maps the target point to the negative z-axis and the eye point to the origin, so that when you use a typical projection matrix, the center of the scene maps to the center of the viewport. Similarly, the direction described by the up vector projected onto the viewing plane is mapped to the positive y-axis so that it points upward in the viewport. The up vector must not be parallel to the line of sight from the eye to the reference point." />
      <item value="@description An orthographic camera projection where the frustum shape is essentially a cuboid." />
      <item value="@description A perspective camera projection where the frustum shape is essentially pyramidal." />
      <item value="@description Marks the end of a block of rendering. This function should be called after a matching call to {@link GraphicsDeviceupdateBegin}. Calls to {@link GraphicsDeviceupdateBegin} and {@link GraphicsDeviceupdateEnd} must not be nested." />
      <item value="@description Marks the beginning of a block of rendering. Internally, this function binds the render target currently set on the device. This function should be matched with a call to {@link GraphicsDeviceupdateEnd}. Calls to {@link GraphicsDeviceupdateBegin}" />
      <item value="@description Marks the beginning of a block of rendering. Internally, this function binds the render target currently set on the device. This function should be matched" />
      <item value="@description Sets the specified render target on the device. If null is passed as a parameter, the back buffer becomes the current target for all rendering operations." />
      <item value="WebGL1 has different requirements for power of 2 images vs non power of 2 images so check if the image is a power of 2 in both dimensions." />
      <item value="No, it's not a power of 2. Turn of mips and set wrapping to clamp to edge" />
      <item value="@description No sorting is applied. Mesh instances are rendered in the same order they were added to a layer." />
      <item value="@description Right of view. Only used in stereo rendering." />
      <item value="@description Left of view. Only used in stereo rendering." />
      <item value="scissor" />
      <item value="@description Set the active scissor rectangle on the specified device." />
      <item value="@param {Vec4} [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z, rect.w) of the rectangle. Default is [0, 0, 1, 1]." />
      <item value="Parametric Geometry" />
      <item value="Parametric Surfaces Geometry" />
      <item value="based on the brilliant article by @prideout https:prideout.netblogoldblogindex.html@p=44.html" />
      <item value="Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="379" />
        <entry key="ENGLISH" value="381" />
        <entry key="LATIN" value="1" />
        <entry key="PORTUGUESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1637552380168" />
  </component>
  <component name="Settings">
    <option name="googleTranslateSettings">
      <google-translate>
        <option name="primaryLanguage" value="CHINESE" />
      </google-translate>
    </option>
  </component>
</application>